% \iffalse meta-comment
%
%% File: tagpdf-roles.dtx
%
% Copyright (C) 2019-2022 Ulrike Fischer
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "tagpdf bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/u-fischer/tagpdf
%
% for those people who are interested.
%<*driver>
\DocumentMetadata{}
\documentclass{l3doc}
\usepackage{array,booktabs,caption}
\hypersetup{pdfauthor=Ulrike Fischer,
 pdftitle=tagpdf-checks module (tagpdf)}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% \title{^^A
%   The \pkg{tagpdf-roles} module\\ Tags, roles and namesspace code   ^^A
%   \\ Part of the tagpdf package
% }
%
% \author{^^A
%  Ulrike Fischer\thanks
%    {^^A
%      E-mail:
%        \href{mailto:fischer@troubleshooting-tex.de}
%          {fischer@troubleshooting-tex.de}^^A
%    }^^A
% }
%
% \date{Version 0.97, released 2022-08-24}
% \maketitle
% \begin{documentation}
% \begin{function}
%  {
%    add-new-tag (setup-key),
%    tag (rolemap-key),
%    namespace (rolemap-key),
%    role (rolemap-key),
%    role-namespace (rolemap-key),
%  }
% The \texttt{add-new-tag} key can be used in \cs{tagpdfsetup} to declare and rolemap new tags.
% It takes as value a key-value list or a simple |new-tag/old-tag|.
%
% The key-value list knows the following keys:
% \begin{description}
% \item[\texttt{tag}] This is the name of the new tag as it should 
% then be used in \cs{tagstructbegin}.
% \item[\texttt{namespace}] This is the namespace of the new tag.
%   The value should be a shorthand of a namespace.
%   The allowed values are currently |pdf|, |pdf2|, |mathml|,|latex|, |latex-book| and |user|.
%   The default value (and recommended value for a new tag) is |user|.
%   The public name of the user namespace is |tag/NS/user|. This can be used to reference
%   the namespace e.g. in attributes.
% \item[\texttt{role}] This is the tag the tag should be mapped too.
%  In a PDF 1.7 or earlier this is normally a tag from the |pdf| set,
%  in PDF 2.0 from the |pdf|, |pdf2| and |mathml| set.
%  It can also be a user tag. The tag must be declared before, as the code retrieves
%  the type of the new tag from it. 
%  The PDF format allows mapping to be done transitively.
%  But tagpdf can't/won't check such unusual role mapping.
% \item[\texttt{role-namespace}] If the role is a known tag
%  the default value is the default namespace of this tag.
%  With this key a specific namespace can be forced.  
% \end{description}
% \end{function}
% \end{documentation}
% \begin{implementation}
%    \begin{macrocode}
%<@@=tag>
%<*header>
\ProvidesExplPackage {tagpdf-roles-code} {2022-08-24} {0.97}
 {part of tagpdf - code related to roles and structure names}
%</header>
%    \end{macrocode}
% \section{Code related to roles and structure names}
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
% \subsection{Variables}
% Tags are used in structures and mc-chunks. 
% They have a name (a string), a number (for the lua attribute), and 
% in PDF 2.0 belong to one or more name spaces, with one being the default
% name space.
% 
% The structures are classified, e.g. as grouping, 
% inline or block level structure (and a few special types like lists and tables),
% and must follow containments rules depending on their classification 
% (for example a inline structure can not contain
% a block level structure). New tags inherit their 
% classification from the standard namespaces (PDF and/or PDF 2.0). 
% We store this as it will probably 
% be needed for tests but currently the data is not used. 
% The classification for math is unclear currently and so not set.
% 
% The attribute number is only relevant in lua and only for the MC type, and so only
% stored if luatex. Tags with the same name from different names 
% spaces can have the same number.
%
% \begin{variable}{\g_@@_role_tags_NS_prop}
% This is the core list of tag names. It uses tags as keys
% and the shorthand (e.g. pdf2, or mathml) of the default name space as value .
% We store the default name space also in pdf <2.0, even if not needed: 
% it doesn't harm and simplifies the code. 
% There is no need to access this from lua, so we use the standard prop commands.
%    \begin{macrocode}
\prop_new:N    \g_@@_role_tags_NS_prop 
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_role_tags_types_prop}
% With pdf 2.0 we store the types in the NS dependant props. 
% With pdf <2.0 we store for now the type(s) of a tag in a common
% prop. 
% Tags that are rolemapped should get the type from
% the target.
%    \begin{macrocode}
\prop_new:N    \g_@@_role_tags_types_prop 
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}{\g_@@_role_NS_prop}
% This holds the list of supported name spaces.
% The keys are the name tagpdf will use, the values the object reference. 
% The urls identifier are stored in related dict object.
% \begin{description}
% \item[mathml] http://www.w3.org/1998/Math/MathML
% \item[pdf2]   http://iso.org/pdf2/ssn
% \item[pdf]    http://iso.org/pdf/ssn (default)
% \item[user]   \cs{c_@@_role_userNS_id_str} (random id, for user tags)
% \item[latex]  https://www.latex-project.org/ns/dflt/2022
% \item[latex-book] https://www.latex-project.org/ns/book/2022
% \item[latex-inline]     https://www.latex-project.org/ns/inline/2022
% \end{description}
% More namespaces are possible and
% their objects references and their rolemaps must be collected
% so that an array can be written to the StructTreeRoot at the end (see tagpdf-tree).
% We use a prop to store the object reference as it will be needed rather
% often.
%    \begin{macrocode}
\prop_new:N \g_@@_role_NS_prop 
%    \end{macrocode}
% \end{variable}
%
% We need also a bunch of temporary variables:
% \begin{variable}
%  {
%     ,\l_@@_role_tag_tmpa_tl
%     ,\l_@@_role_tag_namespace_tmpa_tl
%     ,\l_@@_role_role_tmpa_tl
%     ,\l_@@_role_role_namespace_tmpa_tl
%  }
%    \begin{macrocode}
\tl_new:N \l_@@_role_tag_tmpa_tl
\tl_new:N \l_@@_role_tag_namespace_tmpa_tl
\tl_new:N \l_@@_role_role_tmpa_tl
\tl_new:N \l_@@_role_role_namespace_tmpa_tl
%    \end{macrocode}
% \end{variable}
% 
% \subsection{Namespaces}
% The following commands setups a name space. 
% With pdf version $<$2.0 this is only a prop with the 
% rolemap. With pdf 2.0 a dictionary must be set up. 
% Such a name space dictionaries can
% contain an optional |/Schema| and |/RoleMapNS| entry. We only reserve the
% objects but delay the writing to the finish code, where we can test if the
% keys and the name spaces are actually needed.
% This commands setups objects for the name space and its rolemap. It also
% initialize a dict to collect the rolemaps if needed, and a property
% with the tags of the name space and their rolemapping for loops.
% It is unclear if a reference to a schema file will be ever needed, 
% but it doesn't harm \ldots.
% 
% \begin{variable}{g_@@_role/RoleMap_dict}
% This is the object which contains the normal RoleMap. It is probably not
% needed in pdf 2.0 but currently kept.
%    \begin{macrocode}
\pdfdict_new:n {g_@@_role/RoleMap_dict}
%    \end{macrocode}
% \end{variable}
% 
% \begin{function}{\@@_role_NS_new:nnn}
%  \begin{syntax}
%   \cs{@@_role_NS_new:nnn}\Arg{shorthand}\Arg{URI-ID}{Schema}
%  \end{syntax}
% \end{function}
% \begin{macro}{\@@_role_NS_new:nnn}
%    \begin{macrocode}
\pdf_version_compare:NnTF > {1.9}
 {
  \cs_new_protected:Npn \@@_role_NS_new:nnn #1 #2 #3
    {
      \prop_new:c { g_@@_role_NS_#1_prop }
      \prop_new:c { g_@@_role_NS_#1_types_prop }
      \pdf_object_new:n {tag/NS/#1}
      \pdfdict_new:n     {g_@@_role/Namespace_#1_dict}
      \pdf_object_new:n {@@/RoleMapNS/#1}
      \pdfdict_new:n     {g_@@_role/RoleMapNS_#1_dict}
      \pdfdict_gput:nnn
        {g_@@_role/Namespace_#1_dict}
        {Type}
        {/Namespace}
      \pdf_string_from_unicode:nnN{utf8/string}{#2}\l_@@_tmpa_str
      \tl_if_empty:NF \l_@@_tmpa_str
        {
          \pdfdict_gput:nnx
            {g_@@_role/Namespace_#1_dict}
            {NS}
            {\l_@@_tmpa_str}
        }
      %RoleMapNS is added in tree
      \tl_if_empty:nF  {#3}
       {
         \pdfdict_gput:nnx{g_@@_role/Namespace_#1_dict}
          {Schema}{#3}
       }
      \prop_gput:Nnx \g_@@_role_NS_prop {#1}{\pdf_object_ref:n{tag/NS/#1}~}
    }
 } 
 {
   \cs_new_protected:Npn \@@_role_NS_new:nnn #1 #2 #3
    {
      \prop_new:c { g_@@_role_NS_#1_prop }
      \prop_new:c { g_@@_role_NS_#1_types_prop }
    }
 }
%    \end{macrocode}
% \end{macro}
% We need an id for the user space. For the tests it should be possible
% to set it to a fix value. So we use random numbers which can
% be fixed by setting a seed. We fake a sort of
% GUID but do not try to be really exact as it doesn't matter ...
%
% \begin{variable}{\c_@@_role_userNS_id_str}
%    \begin{macrocode}
\str_const:Nx \c_@@_role_userNS_id_str
  { data:,
    \int_to_Hex:n{\int_rand:n {65535}}
    \int_to_Hex:n{\int_rand:n {65535}}
    -
    \int_to_Hex:n{\int_rand:n {65535}}
    -
    \int_to_Hex:n{\int_rand:n {65535}}
    -
    \int_to_Hex:n{\int_rand:n {65535}}
    -
    \int_to_Hex:n{\int_rand:n {16777215}}
    \int_to_Hex:n{\int_rand:n {16777215}}
  }
%    \end{macrocode}
% \end{variable}
% Now we setup the standard names spaces. 
% The mathml space is currently only loaded for pdf 2.0.
%    \begin{macrocode}
\@@_role_NS_new:nnn {pdf}   {http://iso.org/pdf/ssn}{}
\@@_role_NS_new:nnn {pdf2}  {http://iso.org/pdf2/ssn}{}
\pdf_version_compare:NnT > {1.9}
  {    
    \@@_role_NS_new:nnn {mathml}{http://www.w3.org/1998/Math/MathML}{}
  }  
\@@_role_NS_new:nnn {latex} {https://www.latex-project.org/ns/dflt/2022}{}
\@@_role_NS_new:nnn {latex-book} {https://www.latex-project.org/ns/book/2022}{}
   % \@@_role_NS_new:nnn {latex-inline} {https://www.latex-project.org/ns/inline/2022}{}
\exp_args:Nnx
  \@@_role_NS_new:nnn {user}{\c_@@_role_userNS_id_str}{}
%    \end{macrocode}
%
% \subsection{Adding a new tag}
% Both when reading the files and when setting up a tag manually
% we have to store data in various places.
% 
% \begin{macro}{\@@_role_alloctag:nnn}
% This command allocates a new tag without role mapping. In the 
% lua backend it will also record the attribute value.
%    \begin{macrocode}
\sys_if_engine_luatex:TF
 {
   \cs_new_protected:Npn \@@_role_alloctag:nnn #1 #2 #3 %#1 tagname, ns, type
    {
      \lua_now:e { ltx.@@.func.alloctag ('#1') }
      \prop_gput:Nnn \g_@@_role_tags_NS_prop   {#1}{#2}
      \prop_gput:cnn {g_@@_role_NS_#2_prop}  {#1}{}
      \prop_gput:Nnn \g_@@_role_tags_types_prop {#1}{#3}
      \prop_gput:cnn {g_@@_role_NS_#2_types_prop}  {#1}{#3}
    }      
 }
 {   
   \cs_new_protected:Npn \@@_role_alloctag:nnn #1 #2 #3
    {
      \prop_gput:Nnn \g_@@_role_tags_NS_prop   {#1}{#2}
      \prop_gput:cnn {g_@@_role_NS_#2_prop}  {#1}{}
      \prop_gput:Nnn \g_@@_role_tags_types_prop {#1}{#3}
      \prop_gput:cnn {g_@@_role_NS_#2_types_prop}  {#1}{#3}
    } 
 }   
\cs_generate_variant:Nn  \@@_role_alloctag:nnn {nnV}   
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{pdf 1.7 and earlier}
%
% \begin{macro}{\@@_role_add_tag:nn}
% The pdf 1.7 version has only two arguments: new and rolemap name.
% The role must be an existing tag and should not be empty.
% We allow to change the role of an existing tag: as the rolemap is written
% at the end not confusion can happen.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_role_add_tag:nn % (new) name, reference to old
  {
%    \end{macrocode}
% checks and messages
%    \begin{macrocode}
    \@@_check_add_tag_role:nn {#1}{#2}
    \prop_if_in:NnF \g_@@_role_tags_NS_prop {#1}
      {
        \int_compare:nNnT {\l_@@_loglevel_int} > { 0 }
          {
            \msg_info:nnn { tag }{new-tag}{#1}
          }
      }
%    \end{macrocode}
% now the addition
%    \begin{macrocode}
    \prop_get:NnN \g_@@_role_tags_types_prop {#2}\l_@@_tmpa_tl
    \quark_if_no_value:NT \l_@@_tmpa_tl 
      {
        \tl_set:Nn\l_@@_tmpa_tl{--UNKNOWN--}
      }        
    \@@_role_alloctag:nnV {#1}{user}\l__@@_tmpa_tl  
    \tl_if_empty:nF { #2 }
      {
        \pdfdict_gput:nnx {g_@@_role/RoleMap_dict}
          {#1}
          {\pdf_name_from_unicode_e:n{#2}}
      }
  }
\cs_generate_variant:Nn \@@_role_add_tag:nn {VV}
%    \end{macrocode}
% \end{macro}
% \subsubsection{The pdf 2.0 version}
% \begin{macro}{\@@_role_add_tag:nnnn}
% The pdf 2.0 version takes four arguments:
% tag/namespace/role/namespace
%    \begin{macrocode}
\cs_new_protected:Nn \@@_role_add_tag:nnnn %tag/namespace/role/namespace
  {
    \@@_check_add_tag_role:nnn {#1/#2}{#3}{#4}
    \int_compare:nNnT {\l_@@_loglevel_int} > { 0 }
      {
        \msg_info:nnn { tag }{new-tag}{#1}
      }
    \prop_get:cnN { g_@@_role_NS_#4_types_prop } {#3}\l_@@_tmpa_tl
    \quark_if_no_value:NT \l_@@_tmpa_tl 
      {
        \tl_set:Nn\l_@@_tmpa_tl{--UNKNOWN--}
      }         
    \@@_role_alloctag:nnV {#1}{#2}\l_@@_tmpa_tl    
    \pdfdict_gput:nnx {g_@@_role/RoleMapNS_#2_dict}{#1}
       {
         [
           \pdf_name_from_unicode_e:n{#3}
           \c_space_tl
           \pdf_object_ref:n {tag/NS/#4}
         ]
       }
   }
\cs_generate_variant:Nn \@@_role_add_tag:nnnn {VVVV}
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Helper command to read the data from files}
% In this section we setup the helper command to read namespace files.

% \begin{macro}{\@@_role_read_namespace_line:nw}
% This command will process a line in the name space file.
% The first argument is the name of the name space. 
% The definition differ for pdf 2.0. as we have proper name spaces there.
%    \begin{macrocode}
\pdf_version_compare:NnTF > {1.9}
 {
   \cs_new_protected:Npn \@@_role_read_namespace_line:nw #1#2,#3,#4,#5,#6\q_stop %
    % #1 NS, #2 tag, #3 rolemap, #4 NS rolemap #5 type
    {
      \tl_if_empty:nF {#2}
       {
        \tl_if_empty:nTF {#5}
         {
           \prop_get:cnN { g_@@_role_NS_#4_prop } {#3}\l_@@_tmpa_tl
           \quark_if_no_value:NT \l_@@_tmpa_tl 
             {
               \tl_set:Nn\l_@@_tmpa_tl{--UNKNOWN--}
             } 
         }
         {
           \tl_set:Nn \l_@@_tmpa_tl {#5}
         }     
        \@@_role_alloctag:nnV {#2}{#1}\l_@@_tmpa_tl
        \prop_gput:cnn {g_@@_role_NS_#1_prop}  {#2}{#3}
        \bool_lazy_and:nnT
           { ! \tl_if_empty_p:n {#3} }{! \str_if_eq_p:nn {#1}{pdf2}} 
           {\@@_role_add_tag:nnnn {#2}{#1}{#3}{#4}} 
       }     
    }
 }
 {
  \cs_new_protected:Npn \@@_role_read_namespace_line:nw #1#2,#3,#4,#5,#6\q_stop %
   % #1 NS, #2 tag, #3 rolemap, #4 NS rolemap #5 type
    {
      \tl_if_empty:nF { #2 }
       {
        \tl_if_empty:nTF {#5}
          {
            \prop_get:NnN \g_@@_role_tags_types_prop  {#3}\l_@@_tmpa_tl
            \quark_if_no_value:NT \l_@@_tmpa_tl 
              {
                \tl_set:Nn\l_@@_tmpa_tl{--UNKNOWN--}
              } 
          }
          {
            \tl_set:Nn \l_@@_tmpa_tl {#5}
          }             
        \@@_role_alloctag:nnV {#2}{#1}\l_@@_tmpa_tl
        \prop_gput:cnn {g_@@_role_NS_#1_prop}  {#2}{#3}
        \tl_if_empty:nF {#3}
          { 
            \@@_role_add_tag:nn {#2}{#3} 
          }  
       }     
    }
  }  
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@@_role_read_namespace:n}
% This command reads the namespace file.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_role_read_namespace:n #1 %name of namespace
  { 
    \prop_if_exist:cF {g__tag_role_NS_#1_prop}
      { \msg_warning:nnn {tag}{namespace-unknown}{#1} }
    \file_if_exist:nTF { tagpdf-ns-#1.def}
     { 
       \ior_open:Nn \g_tmpa_ior {tagpdf-ns-#1.def}
       \msg_info:nnn {tag}{read-namespace}{#1}
       \ior_map_inline:Nn \g_tmpa_ior 
         {
           \@@_role_read_namespace_line:nw {#1} ##1,,,,\q_stop 
         }
       \ior_close:N\g_tmpa_ior    
     }
     {
      \msg_warning:nnn{tag}{namespace-missing}{#1}
     }
  }   
   
%    \end{macrocode}
% \end{macro}
%

% 
% \subsection{Reading the default data}
% The order is important as we want pdf2 and latex as default.
%    \begin{macrocode}
\@@_role_read_namespace:n {pdf}
\@@_role_read_namespace:n {pdf2}
\pdf_version_compare:NnT > {1.9}
  {\@@_role_read_namespace:n {mathml}}
\@@_role_read_namespace:n {latex-book}  
\@@_role_read_namespace:n {latex}
%    \end{macrocode}
%
% But is the class provides a \cs{chapter} command then we switch 
%    \begin{macrocode}
\pdf_version_compare:NnTF < {2.0}
  {
    \hook_gput_code:nnn {begindocument}{tagpdf}
      {
        \cs_if_exist:NT \chapter
           {
             \prop_map_inline:cn{g_@@_role_NS_latex-book_prop}
               {
                 \@@_role_add_tag:nn {#1}{#2}
               }
           }
      }
  }
  {
    \hook_gput_code:nnn {begindocument}{tagpdf}
      {
        \cs_if_exist:NT \chapter
         {
           \prop_map_inline:cn{g_@@_role_NS_latex-book_prop}
             {
               \prop_gput:Nnn \g_@@_role_tags_NS_prop    { #1 }{ latex-book }
             }
         }
      }  
  }
%    \end{macrocode}
%
% \subsection{Key-val user interface}
%  The user interface uses the key |add-new-tag|, which takes either a
%  keyval list as argument, or a tag/role.
%  \begin{macro}
%    {
%     tag (rolemap-key),
%     tag-namespace (rolemap-key),
%     role (rolemap-key),
%     role-namespace (rolemap-key),
%     add-new-tag (setup-key)}
%    \begin{macrocode}
\keys_define:nn { @@ / tag-role }
  {
    ,tag .tl_set:N = \l_@@_role_tag_tmpa_tl
    ,tag-namespace  .tl_set:N = \l_@@_role_tag_namespace_tmpa_tl
    ,role .tl_set:N = \l_@@_role_role_tmpa_tl
    ,role-namespace .tl_set:N = \l_@@_role_role_namespace_tmpa_tl
  }

\keys_define:nn { @@ / setup }
  {
    add-new-tag .code:n =
     {
       \keys_set_known:nnnN
         {@@/tag-role}
         {
           tag-namespace=user,
           role-namespace=, %so that we can test for it.
          #1
         }{@@/tag-role}\l_tmpa_tl
       \tl_if_empty:NF \l_tmpa_tl
         {
           \exp_args:NNno \seq_set_split:Nnn \l_tmpa_seq { / } {\l_tmpa_tl/}
           \tl_set:Nx \l_@@_role_tag_tmpa_tl  { \seq_item:Nn \l_tmpa_seq {1} }
           \tl_set:Nx \l_@@_role_role_tmpa_tl { \seq_item:Nn \l_tmpa_seq {2} }
         }
      \tl_if_empty:NT \l_@@_role_role_namespace_tmpa_tl
         {
           \prop_get:NVNTF
             \g_@@_role_tags_NS_prop
             \l_@@_role_role_tmpa_tl
             \l_@@_role_role_namespace_tmpa_tl
             {
                \prop_if_in:NVF\g_@@_role_NS_prop \l_@@_role_role_namespace_tmpa_tl
                 {
                   \tl_set:Nn \l_@@_role_role_namespace_tmpa_tl {user}
                 }
             }
             {
               \tl_set:Nn \l_@@_role_role_namespace_tmpa_tl {user}
             }
         }
      \pdf_version_compare:NnTF < {2.0}
       {
        %TODO add check for emptyness?
          \@@_role_add_tag:VV
              \l_@@_role_tag_tmpa_tl
              \l_@@_role_role_tmpa_tl
       }
       {
         \@@_role_add_tag:VVVV
           \l_@@_role_tag_tmpa_tl
           \l_@@_role_tag_namespace_tmpa_tl
           \l_@@_role_role_tmpa_tl
           \l_@@_role_role_namespace_tmpa_tl
       }
    }
  }
%</package>
%    \end{macrocode}
% \end{macro}
% \end{implementation}
% \PrintIndex
