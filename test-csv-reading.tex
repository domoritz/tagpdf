% !Mode:: "TeX:UTF-8:Main"
\documentclass{article}

\begin{document}
\ExplSyntaxOn
% from tagpdf.dtx ...
\int_new:N \l__tag_tmpa_int
\seq_new:N \l__tag_tmpa_seq
\tl_new:N  \l__tag_tmpa_tl
\tl_new:N  \l__tag_tmpb_tl
%
\prop_new:N      \g__tag_role_index_prop
\intarray_new:Nn \g__tag_role_parent_child_intarray {6000}

\prop_const_from_keyval:Nn \c__tag_role_rules_prop
 {
    0..n = 1,
    0..1 = 2,
    1    = 3, %StructTreeRoot, not really needed
    [a]  = 4, %ruby
    [b]  = 5, %warichu
    c    = 6, % WP ??
    ‡    = 7, % Part,Div,NonStruct -> "check parent"
    ∅*   = 8, % or negative by default?
    ∅    = -1,
 }



\ior_open:Nn \g_tmpa_ior {tagpdf-parent-child.csv}
\int_zero:N  \l__tag_tmpa_int

\tl_new:N \l__tag_childnum_tl
\tl_new:N\l__tag_parent_tmpa_tl

\cs_new_protected:Npn \__tag_store_parent_child_rule:nnn #1 #2 #3 % num parent, num child, #3 string
 {
   \intarray_gset:Nnn \g__tag_role_parent_child_intarray 
      {100*#1 + #2 }{0\prop_item:Nn\c__tag_role_rules_prop{#3}}
 }  
 

                  
\ior_map_inline:Nn \g_tmpa_ior 
  { 
%    \end{macrocode}
% count the lines ...
%    \begin{macrocode}
    \int_incr:N\l__tag_tmpa_int 
%    \end{macrocode}
%  put the line into a seq. Attention! empty cells are dropped.
%    \begin{macrocode}
    \seq_set_from_clist:Nn\l__tag_tmpa_seq { #1 } 
    \int_compare:nNnTF {\l__tag_tmpa_int}=1
%    \end{macrocode}
% This handles the header line. It numbers the tags.
% the StructTreeRoot, Hn, mathml and MC tags are special!
%    \begin{macrocode}
     {         
       \seq_map_indexed_inline:Nn \l__tag_tmpa_seq
         {
           \prop_gput:Nnn\g__tag_role_index_prop {##2}{##1}           
         }  
     }
%    \end{macrocode}
% now the data lines.
%    \begin{macrocode}
     {
       \seq_set_from_clist:Nn\l__tag_tmpa_seq { #1 }
%    \end{macrocode}
% there can be an empty line at the end, so better test.
%    \begin{macrocode}
       \seq_if_empty:NF \l__tag_tmpa_seq 
        {
%    \end{macrocode}
% get the name of the tag
%    \begin{macrocode}
         \seq_pop_left:NN\l__tag_tmpa_seq\l__tag_tmpa_tl
%    \end{macrocode}
% get the number of the child, stored in \cs{l__tag_tmpb_tl}
%    \begin{macrocode}
         \prop_get:NVN \g__tag_role_index_prop \l__tag_tmpa_tl \l__tag_tmpb_tl
%    \end{macrocode}
% remove column 2+3
%    \begin{macrocode}
         \seq_pop_left:NN\l__tag_tmpa_seq\l__tag_tmpa_tl
         \seq_pop_left:NN\l__tag_tmpa_seq\l__tag_tmpa_tl
%    \end{macrocode}
% Now map over the rest. The index \verb+##1+ gives us the 
% number of parent, \verb+##2+ is the data.
%    \begin{macrocode}
         \seq_map_indexed_inline:Nn \l__tag_tmpa_seq 
           {       
             \exp_args:Nnx 
               \__tag_store_parent_child_rule:nnn {##1}{\l__tag_tmpb_tl}{ ##2 }       
           }
        }
     }
  }
%    \end{macrocode}
% close the read handle.
%    \begin{macrocode}
\ior_close:N\g_tmpa_ior 
%    \end{macrocode}
% add the H1, H2 to the index. 
%    \begin{macrocode}
\prop_get:NnN\g__tag_role_index_prop{Hn}\l__tag_tmpa_tl
\int_step_inline:nn{10}
 {
   \prop_gput:Nnx\g__tag_role_index_prop{H#1}{\l__tag_tmpa_tl}
 }
%    \end{macrocode}
% TODO handle mathml tags
%    \begin{macrocode}
\intarray_show:N \g__tag_role_parent_child_intarray

%\edef\blub {\intarray_item:Nn \g__tag_role_parent_child_intarray {1}}\show\blub
\ExplSyntaxOff
\end{document} 