% !Mode:: "TeX:UTF-8:Main"
\DocumentMetadata{uncompress,testphase=phase-II,debug={log=v}}
\documentclass{article}

\begin{document}
\ExplSyntaxOn
\msg_new:nnn { tag } {role-parent-child} { The~relation~of~parent~'#1'~and~child~'#2'~is~#3}
% from tagpdf.dtx ...
%\int_new:N \l__tag_tmpa_int
%\seq_new:N \l__tag_tmpa_seq
%\tl_new:N  \l__tag_tmpa_tl
%\tl_new:N  \l__tag_tmpb_tl
%
\prop_new:N      \g__tag_role_index_prop
\intarray_new:Nn \g__tag_role_parent_child_intarray {6000}

\prop_const_from_keyval:Nn \c__tag_role_rules_prop
 {
    0..n = 1,
    0..1 = 2,
    1    = 3, %StructTreeRoot, not really needed
    [a]  = 4, %ruby
    [b]  = 5, %warichu
    c    = 6, % WP ??
    ‡    = 7, % Part,Div,NonStruct -> "check parent"
    ∅*   = 8, % or negative by default?
    ∅    = -1,
 }
%in debug??
\prop_const_from_keyval:Nn \c__tag_role_rules_num_prop
 {
   1 = 0..n,
   2 = 0..1,
   3 = 1   , %StructTreeRoot, not really needed
   4 = [a] , %ruby
   5 = [b] , %warichu
   6 = c   , % WP ??
   7 = ‡   , % Part,Div,NonStruct -> "check parent"
   8 = ∅*  , % or negative by default?
  -1 = ∅ ,
 }


\ior_open:Nn \g_tmpa_ior {tagpdf-parent-child.csv}
\int_zero:N  \l__tag_tmpa_int

\tl_new:N \l__tag_childnum_tl
\tl_new:N\l__tag_parent_tmpa_tl

\cs_new_protected:Npn \__tag_store_parent_child_rule:nnn #1 #2 #3 % num parent, num child, #3 string
 {
   \intarray_gset:Nnn \g__tag_role_parent_child_intarray 
      {100*#1 + #2 }{0\prop_item:Nn\c__tag_role_rules_prop{#3}}
 }  
 

                  
\ior_map_inline:Nn \g_tmpa_ior 
  { 
%    \end{macrocode}
% count the lines ...
%    \begin{macrocode}
    \int_incr:N\l__tag_tmpa_int 
%    \end{macrocode}
%  put the line into a seq. Attention! empty cells are dropped.
%    \begin{macrocode}
    \seq_set_from_clist:Nn\l__tag_tmpa_seq { #1 } 
    \int_compare:nNnTF {\l__tag_tmpa_int}=1
%    \end{macrocode}
% This handles the header line. It numbers the tags.
% the StructTreeRoot, Hn, mathml and MC tags are special!
%    \begin{macrocode}
     {         
       \seq_map_indexed_inline:Nn \l__tag_tmpa_seq
         {
           \prop_gput:Nnn\g__tag_role_index_prop {##2}{##1}           
         }  
     }
%    \end{macrocode}
% now the data lines.
%    \begin{macrocode}
     {
       \seq_set_from_clist:Nn\l__tag_tmpa_seq { #1 }
%    \end{macrocode}
% there can be an empty line at the end, so better test.
%    \begin{macrocode}
       \seq_if_empty:NF \l__tag_tmpa_seq 
        {
%    \end{macrocode}
% get the name of the tag
%    \begin{macrocode}
         \seq_pop_left:NN\l__tag_tmpa_seq\l__tag_tmpa_tl
%    \end{macrocode}
% get the number of the child, stored in \cs{l__tag_tmpb_tl}
%    \begin{macrocode}
         \prop_get:NVN \g__tag_role_index_prop \l__tag_tmpa_tl \l__tag_tmpb_tl
%    \end{macrocode}
% remove column 2+3
%    \begin{macrocode}
         \seq_pop_left:NN\l__tag_tmpa_seq\l__tag_tmpa_tl
         \seq_pop_left:NN\l__tag_tmpa_seq\l__tag_tmpa_tl
%    \end{macrocode}
% Now map over the rest. The index \verb+##1+ gives us the 
% number of parent, \verb+##2+ is the data.
%    \begin{macrocode}
         \seq_map_indexed_inline:Nn \l__tag_tmpa_seq 
           {       
             \exp_args:Nnx 
               \__tag_store_parent_child_rule:nnn {##1}{\l__tag_tmpb_tl}{ ##2 }       
           }
        }
     }
  }
%    \end{macrocode}
% close the read handle.
%    \begin{macrocode}
\ior_close:N\g_tmpa_ior 
%    \end{macrocode}
% add the H1, H2 to the index. 
%    \begin{macrocode}
\prop_get:NnN\g__tag_role_index_prop{Hn}\l__tag_tmpa_tl
\int_step_inline:nn{10}
 {
   \prop_gput:Nnx\g__tag_role_index_prop{H#1}{\l__tag_tmpa_tl}
 }
%    \end{macrocode}
% TODO handle mathml tags
%    \begin{macrocode}
%\intarray_show:N \g__tag_role_parent_child_intarray
%    \end{macrocode}
% Testing tags.
%    \begin{macrocode}
\cs_new_protected:Npn \__tag_role_get_parent_child:nnN #1 #2 #3% #1 parent #2  #3 tl for state
  {
     \prop_get:NnN\g__tag_role_index_prop{#1}\l__tag_tmpa_tl
     \prop_get:NnN\g__tag_role_index_prop{#2}\l__tag_tmpb_tl
     \bool_lazy_and:nnTF 
       { ! \quark_if_no_value_p:N \l__tag_tmpa_tl }
       { ! \quark_if_no_value_p:N \l__tag_tmpb_tl }
       {
         \tl_set:Nx#3 
           { \intarray_item:Nn 
              \g__tag_role_parent_child_intarray 
              {100*\l__tag_tmpa_tl+\l__tag_tmpb_tl}
           }
%in debug             
         \int_compare:nNnT {\l__tag_loglevel_int} > { 0 }
           {      
             \prop_get:NVN\c__tag_role_rules_num_prop #3 \l__tag_tmpa_tl
             \msg_info:nnxxx 
               { tag } 
               {role-parent-child} 
               { #1 } 
               { #2 }
               { '\l__tag_tmpa_tl' }   
           }  
       }
       {         
         \tl_set:Nn#3 {0}
         \msg_warning:nnxxx 
           { tag } 
           {role-parent-child} 
           { #1 } 
           { #2 }
           { unknown! }  
       }
  }  
%    \end{macrocode}

\__tag_role_get_parent_child:nnN {Document}{P}\l_tmpa_tl
\tl_show:N\l_tmpa_tl

\__tag_role_get_parent_child:nnN {Span}{P}\l_tmpa_tl
\tl_show:N\l_tmpa_tl

\__tag_role_get_parent_child:nnN {Part}{H1}\l_tmpa_tl
\tl_show:N\l_tmpa_tl

\__tag_role_get_parent_child:nnN {Blub}{H1}\l_tmpa_tl
\tl_show:N\l_tmpa_tl

%\edef\blub {\intarray_item:Nn \g__tag_role_parent_child_intarray {1}}\show\blub
\ExplSyntaxOff
\end{document} 